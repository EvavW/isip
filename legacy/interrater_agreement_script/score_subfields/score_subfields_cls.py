

## In this script hierarchy and tree names and child/leaves/files are interchangable.
## nodes are generic term used for root, branches nodes or leaves
#

import os, sys
import re
import functools
import logging
import subprocess

from collections import OrderedDict
from functools import wraps

MAX_ALLOWED_DEPTH = 10
DEFAULT_ROOT = "overall"

## This method creates a complete tree heirarchy based on the fields associated
## in input files. The resultant variable is multidimensional dictionary with 
## tuples (giving ref/hyplist files) at its leaves.
#
def extract_fields_w_files(ref_f, hyp_f):
    
    ## collect file info (continuous) do not break it with /n
    #
    with open(ref_f, 'r') as fr:
        ref_info = fr.read().splitlines()
    
    with open(hyp_f, 'r') as fh:
        hyp_info = fh.read().splitlines()

    ## check the length of ref vs. hyp files for sanity check
    #
    if len(ref_info) != len(hyp_info):
        print "%s -> Error: The reference and hypothesis file lengths are not same... (%s, %s)" \
            %(__name__, ref_f, hyp_f)
        exit(-1)

    ## collect the field names, assuming that files are sorted and created correctly
    #
    field_names = []
    hyp_fields = []
    hier_flag = False

    for refline in ref_info:
        field_names += re.findall (r"\:.*", refline)
        
    ## do sanity check of assigned field names with hyp files
    #
    for hypline in hyp_info:
        hyp_fields += re.findall (r"\:.*", hypline)

    ## sanity check for ref and hyp filelists
    #
    if field_names != hyp_fields:
        print "%s: Error, field names in ref and hyp files are different \n ref -> %s \n hyp -> %s"\
            %(__name__, field_names, hyp_fields)
        exit(-1)

    ## if there is no hierarchy / lists have been created without any fields
    #
    if (field_names == []) and (hyp_fields == []):
        return gen_root_only(ref_info, hyp_info), hier_flag
        
    ## if we are past previous step that means user have provided the hierarchy
    #
    else:
        hier_flag = True
    
    ## check how many subfields are required
    #
    field_depth = 0
    for _f in field_names:
        if find_level(_f) > field_depth:
            field_depth = find_level(_f)


    ## create a dictionary with indicating the level fields
    #
    f_dict = OrderedDict()
    f_dict[DEFAULT_ROOT] = OrderedDict()
    updated_dict = f_dict[DEFAULT_ROOT]
    prev_level = 0
    current_level = 1

    ## keep creating ordered dictionaries until the end of the hierarchy/tree (leaf)
    #
    for subfield_i in range(len(field_names)):

        ## check the level of new subfield
        #
        current_level = find_level(field_names[subfield_i])

        if current_level == prev_level:
            curr_level_dict = update_dict4curr_level(f_dict, current_level)
            if current_level != field_depth:
                updated_dict = create_branchdict_in_tree(curr_level_dict, field_names[subfield_i])
            else:
                updated_dict = create_branchtuple_in_tree(curr_level_dict, field_names, subfield_i, ref_info, hyp_info)
            
        elif current_level <  prev_level:
            curr_level_dict = update_dict4curr_level(f_dict, current_level)
            if current_level != field_depth:
                updated_dict = create_branchdict_in_tree(curr_level_dict, field_names[subfield_i])
            else:
                updated_dict = create_branchtuple_in_tree(curr_level_dict, field_names, subfield_i, ref_info, hyp_info)

        elif current_level >  prev_level:

            curr_level_dict = update_dict4curr_level(f_dict, current_level)
            if current_level != field_depth:
                updated_dict = create_branchdict_in_tree(curr_level_dict, field_names[subfield_i])
            else:
                updated_dict = create_branchtuple_in_tree(curr_level_dict, field_names, subfield_i, ref_info, hyp_info)

        prev_level = current_level

    ## return created directory tree with fields in hierarchy 
    #
    return f_dict, hier_flag

## end of extract_fields_w_files method
#


## This method expects the tree hierarchy generated by extract_fields_w_files
## method, which includes filelists at its leaves. This method collects files
## associated with all levels and returns back the list of files in dictionary form
## main root will include all the files, branck following that will include all 
## files associated with its sub-branches and its leaves and so on...
#
def collect_files_per_level(h_dict_a, score_src_a, prefix = ""):
    
    depth = 0
    ## This recursive function loops until the leaf (tuple) to collect all possible
    ## fields passed in input argument
    #
    if isinstance(h_dict_a, dict):
        ## loop from current level in heirarchy
        #
        for _k in h_dict_a:

            ## update the key name so that it is more representative of 
            ## the heirarchy level.
            ## i.e. :patient: ::session:: will become patient_session as key
            #
            agg_k = prefix + _k.strip(":")
            score_src_a[agg_k] = OrderedDict()
            ## create two more sub dictionary for reference and hypothesis files
            #
            score_src_a[agg_k]["ref"] = []
            score_src_a[agg_k]["hyp"] = []
            
            ## collect all the files downwards in the heirarchy
            #
            collect_leaves(h_dict_a[_k], score_src_a, agg_k, depth)

            depth += 1

            ## recurse through the same function to move downwards in heirarchy
            #
            collect_files_per_level(h_dict_a[_k], score_src_a, prefix = agg_k + "_")

    ## return gracefully
    #

## end of collect_files_per_level method
#


## This function collects all the files/leaves in the heirarchical structure
## This is a recursive function waiting for the end/leaves of the heirarchy to
## arrive to collec its elements (filenames)
#
## leaves argument is for recursion only. do not pass it during the first go
#
def collect_leaves(node, score_src, key_a, depth_a):#, leaves = []):
    ## collect leaves
    if isinstance(node, tuple):
        score_src[key_a]['ref'] += node[0]
        score_src[key_a]['hyp'] += node[1]

    ## if its a dictionary that means its still not end/bottom of the heirarchy
    #
    elif isinstance(node, dict):

        depth_a += 1
        for k in node:
            ## recurse through the same function to downwards in heirarchy
            #
            collect_leaves(node[k], score_src, key_a, depth_a)

    ## sanity check
    else:
        print "%s Error: All levels in heirarchy doesn't extend upto same level\n check input listfiles... (%s not a leave)"\
            %(__name__, node)
        exit(-1)

    ## return gracefully
    #

## end of collect_leaves method
#

#####################################
### create the field tree related ###
#####################################

## This function checks the level of hierarchy / tree based on # of ":" in field
## i.e. ":::" has depth/level of 3
#
def find_level(subfield_a):
    
    for i in range(1, MAX_ALLOWED_DEPTH):
        regex_str = "%s([a-zA-Z0-9_]+)%s$"%(r":"*i, r":"*i)
        if len( re.findall (r"%s"%regex_str, subfield_a) ) > 0:
            break
    ## return the level of the field
    #
    return i


## This function updates the location of dictionary in heirarchy. Which helps creating
## subbranch from a particular level. For example, after creating 3 dimensional dictionary
## It is hard to revert back to the the first or second level and continue branching from
## initial branchs. This function helps reverting back in OrderedDictionary.
## sorted input lists and field names are expected.
#
def update_dict4curr_level(f_dict_a, curr_level_a):

    ## this is the pattern for Ordered Dictionaries which are tree like higher dimensional heirarchy
    ## Following are the levels
    ## f_dict[ f_dict.keys()[-1] ]
    ## f_dict[ f_dict.keys()[-1] ] [f_dict[f_dict.keys()[-1]].keys()[-1]  ] 
    ## f_dict[ f_dict.keys()[-1] ] [f_dict[f_dict.keys()[-1]].keys()[-1]  ] [f_dict[ f_dict.keys()[-1] ] [f_dict[f_dict.keys()[-1]].keys()[-1]  ].keys()[-1]]
    ##
    ## end of example
    ##

    ## initialize variables
    #
    cmd = ""
    ## first level /root of the tree variable
    #
    ###print " overall tree... ", f_dict_a
    fx = "f_dict_a[ f_dict_a.keys()[-1]]"
    ###exec("print 'processing tree...', %s"%fx)

    for i in range(1, curr_level_a):

        ## check the example in comments, this line does something like that...
        #
        cmd += fx

        ## creates command string for deeper branches
        #
        fx = fx + "[" + fx + ".keys()[-1]]"
        ###exec("print 'processing tree...', %s"%fx)
    
    ## return the executed tree/dictionary location, this gives you exact location in hierarchy
    #
    exec("leaf_dict = %s"%fx)
    
    ## return the location gracefully
    #
    return leaf_dict

## end of update_dict4curr_level method
#

## update the dictionary from the branch level
#
def create_branchdict_in_tree(dict_a, subfield_a):
    dict_a[subfield_a] = OrderedDict()
    return dict_a[subfield_a]

## end of create_branchdict_in_tree method
#

## update the tuple at the last level (leaf)
#
def create_branchtuple_in_tree(dict_a, fields_a, subfield_i_a, ref_list_a, hyp_list_a):

    dict_a[fields_a[subfield_i_a]] = (  collect_files_of_field(ref_list_a, fields_a, subfield_i_a),\
                           collect_files_of_field(hyp_list_a, fields_a, subfield_i_a)  )
    return dict_a[fields_a[subfield_i_a]]

## end of create_branchtuple_in_tree method
#


## collect files related to a field and pass it back as a list
#
def collect_files_of_field(flist_a, fields_a,  subfield_i_a):
    
    field_files = []
    detect_flag = False
    count = -1 ## because first element starts from 0

    ## loop through all the elements to find field and related files
    #
    for _el in flist_a:

        if ":" in _el:
            count += 1

        if detect_flag == True:
            ## exit the loop when next field is detected
            if ":" in _el:
                break
            field_files.append(_el) ## updating the files

        ## start collecting fields when fieldname matches
        #
        if count == subfield_i_a:
            detect_flag = True

    ## return field related files
    #
    return field_files

## end of collect_files_of_field method
#

def gen_root_only(reflist_a, hyplist_a):
    
    root = OrderedDict()
    root[DEFAULT_ROOT] = OrderedDict()
    root[DEFAULT_ROOT]["ref"] = reflist_a
    root[DEFAULT_ROOT]["hyp"] = hyplist_a

    return root
############################################ END ##############################################

## TODO: update the sort section so that it can automatically sort input files
## There several styles for sorting i.e. C style, Linux style, etc...

## define a decorator
#
def _score(func):  
    ## TODO: update the flags so that you can collect it from the configuration file...

    def process_lists(*args, **kwargs):

        ## pass reference and hyposthesis filelists for 
        ## extraction of fields as a hierarchy
        #
        separated_f_hier, hier_flag = extract_fields_w_files(args[1], args[2])
        
        ## collect sets to be scored from the tree
        #
        if not hier_flag:
            return func(args[0], separated_f_hier)

        score_src = OrderedDict()
        collect_files_per_level(separated_f_hier, score_src)

        return func(args[0], score_src)

        ## return the entire collection of fields' heirarchy with files
        #
###        return score_src

    ## return executed function ?!!
    #
    return process_lists


## use class to preserve the argument and function names
#
class score_fields(object):

    def __init__(self, func_a, sep_fields, autosort):
        self.func_d = func_a
        self.sep_fields_d = sep_fields
        self.autosort_d = autosort
        

    ## for function calls
    #
    def __call__(self, reflist, hyplist):
        
        print "decorating: ", self.func_d.__name__, "'s arguments..."

        f_dict = self.score(reflist, hyplist)
        

    @_score
    def score(self, *args):

        ## collect the hierarchical dictionary (This step is here because return is 
        ## in tuple form.
        #
        for _arg in args:
            hierarchy_dict = _arg

        print "...scoring the hierarchy..."

        ## score the fields in sets
        #
        for _k in hierarchy_dict:

            self.func_d(hierarchy_dict[_k]['ref'], hierarchy_dict[_k]['hyp'], _k)
        
        print "... Hierarchical scoring is finished ..."




